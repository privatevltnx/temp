<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VoltNexis • Any → Any Image Converter</title>
  <meta name="description" content="Convert images between many formats (PNG, JPG, WEBP, AVIF, JXL, more) fully in your browser. Free, fast, private. No backend." />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, "Noto Sans", sans-serif; }
    .drop-active { border-color: #22c55e !important; background: rgba(34,197,94,0.06) !important; }
    .thumb { width: 72px; height: 72px; object-fit: cover; border-radius: 0.75rem; }
    .icon-btn { display:inline-flex; align-items:center; justify-content:center; border-radius:0.75rem; padding:0.5rem; border:1px solid rgb(226 232 240); }
  </style>
  <!-- JSZip & FileSaver for batch ZIP downloads -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body class="min-h-screen bg-gradient-to-b from-slate-50 to-white text-slate-800">
  <!-- Header -->
  <header class="sticky top-0 z-10 backdrop-blur bg-white/70 border-b border-slate-200">
    <div class="max-w-6xl mx-auto px-4 py-3 flex items-center gap-3">
      <div class="h-9 w-9 rounded-2xl bg-slate-900 grid place-items-center">
        <img src="logo-bg.webp" alt="Icon" class="h-6 w-6 object-contain" />
      </div>

      <div class="flex-1">
        <h1 class="text-xl sm:text-2xl font-bold tracking-tight">VoltNexis Converter</h1>
        <p class="text-xs text-slate-500 -mt-1">Any → Any • 100% Front‑End • Private</p>
      </div>
      <a href="https://voltnexis.github.io" class="rounded-2xl bg-slate-900 text-white px-3 py-2 text-sm font-medium hover:bg-slate-800">Main Site ↗</a>
    </div>
  </header> <main class="max-w-6xl mx-auto px-4 pb-28 pt-6">
    <!-- Controls + Dropzone -->
    <section class="grid gap-5 sm:grid-cols-2">
      <!-- Upload Card -->
      <div class="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm">
        <h2 class="font-semibold text-lg">1) Add files (≤ 50 MB each)</h2>
        <div id="dropzone" class="mt-3 rounded-2xl border border-dashed border-slate-300 bg-slate-50 p-6 flex flex-col items-center justify-center text-center transition">
          <div class="text-sm text-slate-600">Drag & drop images here</div>
          <div class="text-xs text-slate-500 mt-1">or</div>
          <label class="mt-3 inline-flex items-center gap-2 rounded-xl bg-slate-900 px-4 py-2 text-white cursor-pointer hover:bg-slate-800 active:scale-[0.99]">
            <input id="fileInput" type="file" accept="image/*" multiple class="hidden" />
            <span>Select images</span>
          </label>
          <p class="text-xs text-slate-500 mt-2">Common inputs: PNG, JPG/JPEG, WEBP, AVIF, GIF, BMP, SVG*</p>
          <p class="text-xs text-slate-400">*SVG rasterizes to chosen size.</p>
        </div>
        <div class="mt-3 flex items-center justify-between">
          <div id="status" class="text-sm text-slate-600"></div>
          <button id="clearAll" class="text-sm rounded-xl border px-3 py-1.5 hover:bg-slate-50">Clear All</button>
        </div>
        <ul id="fileList" class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-3"></ul>
      </div><!-- Settings Card -->
  <div class="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm">
    <h2 class="font-semibold text-lg">2) Convert settings</h2>
    <div class="mt-4 grid gap-4">
      <div class="grid grid-cols-[140px_1fr] items-center gap-3">
        <label class="text-sm text-slate-600">Output format</label>
        <select id="format" class="w-full rounded-xl border border-slate-300 bg-white px-3 py-2 text-sm"></select>
      </div>

      <div class="grid grid-cols-[140px_1fr] items-center gap-3">
        <label class="text-sm text-slate-600">Quality</label>
        <div class="flex items-center gap-3">
          <input id="quality" type="range" min="1" max="100" value="82" class="w-full" />
          <span id="qval" class="w-10 text-right text-sm text-slate-700">82</span>
        </div>
      </div>

      <div class="grid grid-cols-[140px_1fr] items-start gap-3">
        <span class="text-sm text-slate-600">Resize</span>
        <div class="flex flex-wrap items-center gap-3">
          <input id="resizeW" type="number" min="1" placeholder="width" class="w-28 rounded-xl border border-slate-300 px-3 py-2 text-sm" />
          <span class="text-slate-500">×</span>
          <input id="resizeH" type="number" min="1" placeholder="height" class="w-28 rounded-xl border border-slate-300 px-3 py-2 text-sm" />
          <label class="inline-flex items-center gap-2 text-sm text-slate-700">
            <input id="lockAR" type="checkbox" class="rounded border-slate-300" checked /> Keep aspect
          </label>
        </div>
      </div>

      <div class="grid grid-cols-[140px_1fr] items-start gap-3">
        <span class="text-sm text-slate-600">Naming</span>
        <label class="inline-flex items-center gap-2 text-sm text-slate-700">
          <input id="keepName" type="checkbox" class="rounded border-slate-300" checked /> Keep original name
        </label>
      </div>

      <button id="convertBtn" class="mt-2 inline-flex items-center justify-center rounded-xl bg-emerald-600 px-4 py-2 text-white font-medium shadow-sm hover:bg-emerald-500 active:scale-[0.99] disabled:opacity-50 disabled:cursor-not-allowed">Convert</button>
    </div>
  </div>
</section>

<!-- Results -->
<section class="mt-6 rounded-2xl border border-slate-200 bg-white p-5 shadow-sm">
  <div class="flex items-center justify-between">
    <h2 class="font-semibold text-lg">3) Results</h2>
    <button id="downloadAll" class="hidden rounded-xl bg-slate-900 text-white px-3 py-2 text-sm font-medium hover:bg-slate-800">Download All (ZIP)</button>
  </div>
  <div id="results" class="mt-4 grid gap-4 md:grid-cols-2"></div>
</section>

<footer class="mt-8 text-xs text-slate-500 text-center">
  <p>All conversions run locally in your browser. Files never leave your device. ✨</p>
</footer>

  </main> <script type="module">
    // --- External codecs (Squoosh) ---
    // We dynamically import @squoosh/lib when needed to keep initial load small.
    let SQUOOSH = null;

    async function loadSquoosh() {
      if (SQUOOSH) return SQUOOSH;
      // Using a pinned version for stability.
      SQUOOSH = await import('https://unpkg.com/@squoosh/lib@0.4.0/dist/index.js');
      return SQUOOSH;
    }

    // --- DOM helpers ---
    const $ = (s) => document.querySelector(s);
    const fileInput = $('#fileInput');
    const dropzone = $('#dropzone');
    const fileList = $('#fileList');
    const formatSel = $('#format');
    const qRange = $('#quality');
    const qVal = $('#qval');
    const resizeW = $('#resizeW');
    const resizeH = $('#resizeH');
    const lockAR = $('#lockAR');
    const keepName = $('#keepName');
    const convertBtn = $('#convertBtn');
    const statusEl = $('#status');
    const clearAllBtn = $('#clearAll');
    const results = $('#results');
    const downloadAllBtn = $('#downloadAll');

    // --- State ---
    const MAX = 50 * 1024 * 1024; // 50 MB per file
    let files = []; // [{file, url, w, h}]
    let outputs = []; // [{name, blob, url}]

    // --- Utils ---
    const humanSize = (bytes) => {
      const u = ['B','KB','MB','GB'];
      let i = 0, n = bytes;
      while (n >= 1024 && i < u.length-1) { n/=1024; i++; }
      return `${n.toFixed(n < 10 && i>0 ? 1:0)} ${u[i]}`;
    };
    const extFromType = (t) => t?.split('/')[1]?.split(';')[0] || 'bin';
    const pickDefaultOut = (mime) => {
      if (!mime) return 'image/webp';
      if (mime.includes('png')) return 'image/webp';
      if (mime.includes('jpeg') || mime.includes('jpg')) return 'image/webp';
      if (mime.includes('webp')) return 'image/png';
      if (mime.includes('avif')) return 'image/webp';
      return 'image/webp';
    };

    function setFormatOptions(defaultType='image/webp') {
      const opts = [
        ['image/webp','WEBP (.webp)'],
        ['image/avif','AVIF (.avif)'],
        ['image/jpeg','JPEG (.jpg)'],
        ['image/png','PNG (.png)'],
        ['image/jxl','JXL (.jxl)']
      ];
      formatSel.innerHTML = '';
      for (const [val,label] of opts) {
        const o = document.createElement('option');
        o.value = val; o.textContent = label; formatSel.appendChild(o);
      }
      formatSel.value = defaultType;
      // Disable unsupported types if the browser can't create blobs for them via canvas (Squoosh will handle, but keep UX hints minimal)
      // We'll keep them enabled since Squoosh does the heavy lifting.
    }

    // Show quality number
    qRange.addEventListener('input', () => (qVal.textContent = qRange.value));

    // Maintain aspect ratio
    let ar = null; // width/height based on first image or last probed image
    function updateResizeByWidth() {
      if (lockAR.checked && ar && resizeW.value) {
        resizeH.value = Math.max(1, Math.round(Number(resizeW.value) / ar));
      }
    }
    function updateResizeByHeight() {
      if (lockAR.checked && ar && resizeH.value) {
        resizeW.value = Math.max(1, Math.round(Number(resizeH.value) * ar));
      }
    }
    resizeW.addEventListener('input', updateResizeByWidth);
    resizeH.addEventListener('input', updateResizeByHeight);

    // File handling
    function addFiles(list) {
      const accepted = [];
      for (const f of list) {
        if (!f.type.startsWith('image/')) { toast(`Skipped non-image: ${f.name}`); continue; }
        if (f.size > MAX) { toast(`Skipped >50MB: ${f.name} (${humanSize(f.size)})`); continue; }
        const url = URL.createObjectURL(f);
        accepted.push({ file:f, url, w:null, h:null });
      }
      files = files.concat(accepted);
      if (files.length) {
        const def = pickDefaultOut(files[0].file.type);
        setFormatOptions(def);
        probeDimensions(accepted);
      }
      renderFileList();
    }

    async function probeDimensions(items) {
      for (const it of items) {
        try {
          const img = new Image();
          img.decoding = 'async';
          const p = new Promise((res, rej) => { img.onload = () => res(); img.onerror = rej; });
          img.src = it.url; await p;
          it.w = img.naturalWidth; it.h = img.naturalHeight;
          if (!resizeW.value && !resizeH.value) {
            ar = it.w / it.h;
            resizeW.placeholder = it.w; resizeH.placeholder = it.h;
          }
        } catch {}
      }
    }

    function renderFileList() {
      fileList.innerHTML = '';
      if (!files.length) { fileList.innerHTML = '<li class="text-sm text-slate-500">No files added yet.</li>'; return; }
      for (const [idx, it] of files.entries()) {
        const li = document.createElement('li');
        li.className = 'flex items-center gap-3 rounded-xl border border-slate-200 bg-white p-3';
        const img = document.createElement('img'); img.className = 'thumb'; img.src = it.url; img.alt = it.file.name;
        const meta = document.createElement('div'); meta.className = 'min-w-0 flex-1';
        meta.innerHTML = `<div class="truncate text-sm font-medium">${it.file.name}</div>
                          <div class="text-xs text-slate-500">${it.file.type || 'unknown'} · ${humanSize(it.file.size)}${it.w?` · ${it.w}×${it.h}`:''}</div>`;
        const rm = document.createElement('button'); rm.className='ml-auto text-xs rounded-lg border px-2 py-1 hover:bg-slate-50'; rm.textContent='Remove';
        rm.onclick = () => { URL.revokeObjectURL(it.url); files.splice(idx,1); renderFileList(); };
        li.append(img, meta, rm); fileList.appendChild(li);
      }
    }

    // Drag & drop
    ;['dragenter','dragover'].forEach(evt => dropzone.addEventListener(evt, e => { e.preventDefault(); dropzone.classList.add('drop-active'); }));
    ;['dragleave','drop'].forEach(evt => dropzone.addEventListener(evt, e => { e.preventDefault(); dropzone.classList.remove('drop-active'); }));
    dropzone.addEventListener('drop', (e) => addFiles(e.dataTransfer.files));
    fileInput.addEventListener('change', (e) => addFiles(e.target.files));

    // Toasts
    function toast(msg) { statusEl.textContent = msg; statusEl.classList.remove('text-emerald-600'); statusEl.classList.add('text-slate-600'); }
    function ok(msg) { statusEl.textContent = msg; statusEl.classList.remove('text-slate-600'); statusEl.classList.add('text-emerald-600'); }

    // Conversion using Squoosh for broad format support; fallback to canvas for simple cases
    async function convertBlob(inputFile, outType, quality01, resizeTarget) {
      const mimeSimple = ['image/png','image/jpeg','image/webp','image/avif'];
      const needsSquoosh = !mimeSimple.includes(outType);
      // If resizing is requested, we'll use canvas pipeline (fast) and then encode with squoosh if needed.

      // 1) Decode → canvas bitmap
      async function decodeToCanvas(file) {
        // Prefer createImageBitmap for speed
        const url = URL.createObjectURL(file);
        try {
          const bmp = await createImageBitmap(file);
          const canvas = (window.OffscreenCanvas) ? new OffscreenCanvas(bmp.width, bmp.height) : Object.assign(document.createElement('canvas'), {width:bmp.width, height:bmp.height});
          const ctx = canvas.getContext('2d');
          ctx.drawImage(bmp, 0, 0);
          return canvas;
        } finally { URL.revokeObjectURL(url); }
      }

      const canvas = await decodeToCanvas(inputFile);

      // 2) Resize if requested
      let targetW = canvas.width, targetH = canvas.height;
      if (resizeTarget && (resizeTarget.w || resizeTarget.h)) {
        if (resizeTarget.w && resizeTarget.h) { targetW = resizeTarget.w; targetH = resizeTarget.h; }
        else if (resizeTarget.w) { targetW = resizeTarget.w; targetH = Math.round((canvas.height / canvas.width) * targetW); }
        else if (resizeTarget.h) { targetH = resizeTarget.h; targetW = Math.round((canvas.width / canvas.height) * targetH); }
        const c2 = (window.OffscreenCanvas) ? new OffscreenCanvas(targetW, targetH) : Object.assign(document.createElement('canvas'), {width:targetW, height:targetH});
        const ctx2 = c2.getContext('2d');
        ctx2.imageSmoothingQuality = 'high';
        ctx2.drawImage(canvas, 0, 0, targetW, targetH);
        // replace
        // @ts-ignore
        canvas.width = targetW; canvas.height = targetH; const ctx = canvas.getContext('2d'); ctx.drawImage(c2, 0, 0);
      }

      // 3) Encode
      if (!needsSquoosh) {
        const blob = await new Promise((res, rej) => {
          const q = outType==='image/png' ? undefined : Math.min(1, Math.max(0.01, quality01));
          if (canvas instanceof OffscreenCanvas) canvas.convertToBlob({ type: outType, quality: q }).then(res, rej);
          else canvas.toBlob(b => b?res(b):rej(new Error('toBlob failed')), outType, q);
        });
        return blob;
      }

      // Use Squoosh encoders for formats like JXL or for consistent quality across browsers
      const { ImagePool, encoders } = await loadSquoosh();
      const pool = new ImagePool(navigator.hardwareConcurrency || 2);
      const arrayBuf = await new Response(canvas instanceof OffscreenCanvas ? await canvas.convertToBlob() : await new Promise(res=>canvas.toBlob(res))).arrayBuffer();
      const img = await pool.ingestImage(arrayBuf);

      const qualityPct = Math.round(quality01 * 100);
      const cfg = {};
      if (outType==='image/jxl') cfg.jxl = { quality: qualityPct };
      else if (outType==='image/webp') cfg.webp = { quality: qualityPct };
      else if (outType==='image/avif') cfg.avif = { cqLevel: Math.round((100-qualityPct)/3) };
      else if (outType==='image/jpeg') cfg.mozjpeg = { quality: qualityPct };
      else if (outType==='image/png') cfg.oxipng = { level: 2 };
      else { // default to webp if unknown
        cfg.webp = { quality: qualityPct };
      }

      await img.encode(cfg);
      let out;
      if (cfg.jxl) out = (await img.encodedWith.jxl).binary;
      else if (cfg.webp) out = (await img.encodedWith.webp).binary;
      else if (cfg.avif) out = (await img.encodedWith.avif).binary;
      else if (cfg.mozjpeg) out = (await img.encodedWith.mozjpeg).binary;
      else if (cfg.oxipng) out = (await img.encodedWith.oxipng).binary;
      await pool.close();
      return new Blob([out], { type: outType });
    }

    function withNewExt(name, outType) {
      const map = { 'image/png':'png','image/jpeg':'jpg','image/webp':'webp','image/avif':'avif','image/jxl':'jxl' };
      const ext = map[outType] || extFromType(outType);
      const base = name.includes('.') ? name.slice(0, name.lastIndexOf('.')) : name;
      return `${base}.${ext}`;
    }

    function renderResultThumb(outBlob, outName) {
      const card = document.createElement('div');
      card.className = 'rounded-xl border border-slate-200 p-3 flex items-center gap-3';

      const left = document.createElement('div'); left.className = 'flex items-center gap-3 min-w-0';
      const img = document.createElement('img'); img.className = 'thumb'; img.src = URL.createObjectURL(outBlob); img.alt = outName;
      const meta = document.createElement('div'); meta.className='min-w-0';
      meta.innerHTML = `<div class="text-sm font-medium truncate">${outName}</div>
                        <div class="text-xs text-slate-500">${humanSize(outBlob.size)}</div>`;

      const actions = document.createElement('div'); actions.className = 'ml-auto flex items-center gap-2';
      const dl = document.createElement('button'); dl.className='icon-btn'; dl.title='Download'; dl.innerHTML='⬇️';
      dl.onclick = () => saveAs(outBlob, outName);

      actions.appendChild(dl); left.append(img, meta); card.append(left, actions); results.appendChild(card);

      const url = img.src; // for later cleanup
      outputs.push({ name: outName, blob: outBlob, url });
      updateDownloadAllVisibility();
    }

    function updateDownloadAllVisibility() {
      downloadAllBtn.classList.toggle('hidden', outputs.length < 2);
    }

    async function handleConvert() {
      if (!files.length) { toast('Please add some images first.'); return; }
      convertBtn.disabled = true; results.innerHTML = ''; outputs.forEach(o=>URL.revokeObjectURL(o.url)); outputs = [];

      const outType = formatSel.value;
      const q01 = Math.min(1, Math.max(0.01, Number(qRange.value)/100));

      // Determine resize target
      const target = { w: Number(resizeW.value)||0, h: Number(resizeH.value)||0 };

      for (let i=0;i<files.length;i++) {
        const it = files[i];
        statusEl.textContent = `Converting ${i+1}/${files.length}: ${it.file.name}`;
        try {
          const blob = await convertBlob(it.file, outType, q01, target);
          const name = keepName.checked ? withNewExt(it.file.name, outType) : `converted_${i+1}.${extFromType(outType)}`;
          renderResultThumb(blob, name);
        } catch (e) {
          console.error(e); toast(`Failed: ${it.file.name} (${e.message})`);
        }
      }
      ok('Done. You can download files below.');
      convertBtn.disabled = false;
    }

    async function downloadAllZip() {
      if (!outputs.length) return;
      const zip = new JSZip();
      for (const o of outputs) zip.file(o.name, o.blob);
      const content = await zip.generateAsync({ type: 'blob' });
      saveAs(content, 'converted_images.zip');
    }

    function clearAll() {
      // Revoke all blob URLs
      for (const f of files) URL.revokeObjectURL(f.url);
      for (const o of outputs) URL.revokeObjectURL(o.url);
      files = []; outputs = []; fileList.innerHTML=''; results.innerHTML=''; statusEl.textContent='';
      downloadAllBtn.classList.add('hidden');
      resizeW.value=''; resizeH.value=''; resizeW.placeholder=''; resizeH.placeholder='';
      setFormatOptions('image/webp');
    }

    // Keep data until explicit clear/back/refresh
    window.addEventListener('beforeunload', () => {
      // Cleanup in-memory URLs on navigation/refresh
      for (const f of files) URL.revokeObjectURL(f.url);
      for (const o of outputs) URL.revokeObjectURL(o.url);
    });

    // Bind UI
    convertBtn.addEventListener('click', handleConvert);
    downloadAllBtn.addEventListener('click', downloadAllZip);
    clearAllBtn.addEventListener('click', clearAll);

    // Init
    setFormatOptions('image/webp');
  </script></body>
</html>
